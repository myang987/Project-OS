package io;

import exceptions.DuplicateException;
import exceptions.FileNotExistException;
import exceptions.IllegalNameException;
import exceptions.NotADirectoryException;
import java.util.Iterator;
import util.CmdOutput;
import util.CmdOutput.OutMode;
import util.Message;
import util.Path;
import util.PathInterpreter;

/**
 * This class is responsible for handling the {@code CmdOutput} objects
 * generated by command calls.
 */
public class OutputHandler {

  private final PathInterpreter pathInterpreter;

  public OutputHandler(PathInterpreter pathInterpreter) {
    this.pathInterpreter = pathInterpreter;
  }

  /**
   * Handles {@code output} according to the specified method in it.
   * <p>
   * There are three possible resolutions for a {@code CmdOutput} object. Print,
   * append to a file, or overwrite a file, specified in the {@code outMode}
   * field in {@code CmdOutput} class.
   *
   * @param output The output from command to be handled.
   * @throws NotADirectoryException When {@code redirectTo} tries to navigate
   *                                through a file that is not at the end of it,
   *                                or when attempting to create a new file or
   *                                directory inside a file.
   * @throws DuplicateException     When attempting to create a new file or
   *                                directory in somewhere already has a file or
   *                                directory of the same name.
   * @throws IllegalNameException   When trying to create a file or directory
   *                                with illegal character in its name.
   * @throws FileNotExistException  When a path tries to navigate through a non
   *                                existing file or directory that is not at
   *                                the end of the path.
   * @see CmdOutput#getOutMode()
   */
  public void handle(CmdOutput output)
      throws NotADirectoryException, FileNotExistException, DuplicateException,
      IllegalNameException {
    if (output == null || output.isNoOutPut()) {
      return;
    }
    OutMode mode = output.getOutMode();
    if (mode.equals(OutMode.PRINT)) {
      print(output, output.getLineSeparator());
      System.out.println();
    } else {
      handleRedirection(output);
    }
  }

  /**
   * Prints all strings in {@code m} followed by a {@code endWith}.
   * <p>
   * This method will automatically call {@code resetMessage} on {@code m} so
   * that it always prints from the beginning.
   *
   * @param msg     the message to be printed
   * @param endWith the string between each item in the message
   */
  public void print(Message msg, String endWith) {
    if (msg == null) {
      return;
    }
    for (Iterator<String> itr = msg.iterator(); itr.hasNext(); ) {
      System.out.print(itr.next());
      if (itr.hasNext()) {
        System.out.print(endWith);
      }
    }
  }

  private void handleRedirection(CmdOutput output)
      throws NotADirectoryException, FileNotExistException, DuplicateException,
      IllegalNameException {
    Path path = output.getRedirectTo();
    FolderElement out = pathInterpreter.toFolderElement(path);
    if (out instanceof Directory) {
      throw new FileNotExistException(path + ": is a directory");
    }
    File outfile = (File) out;
    if (out == null) {
      out = pathInterpreter.createDummyAt(path);
      outfile = out.getParentDir().createFile(out.getName());
    }
    if (output.getOutMode().equals(OutMode.OVERWRITE_FILE)) {
      outfile.overwriteContentsAs("");
    }
    writeToFile(outfile, output, output.getLineSeparator());
    // Append a newline char nevertheless to ensure that spacing does not go
    // wrong when printing the file out.
    outfile.appendToContents("\n");
  }

  private void writeToFile(File f, CmdOutput msg, String endLinesWith) {
    for (Iterator<String> itr = msg.iterator(); itr.hasNext(); ) {
      f.appendToContents(itr.next());
      if (itr.hasNext()) {
        f.appendToContents(endLinesWith);
      }
    }
  }

}
